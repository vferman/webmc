{-
Project: WebMC: a model checker for the web
Author: Victor Ferman
File: Server.hs
Description: This file defines a generic server's actions an capabilities,
    used in order to process requests and responses as a server would, will
    output Responses to each received Request
-}

module Server where

import           Data.List
import qualified Data.Map   as Map
import           Data.Maybe
import Data.Either
import           Debug.Trace
import           Encryption
import           Types


{-
    Functions in charge of instantiating servers and of getting the actions
    that can be performed at any given time useful for the Planner
-}

--just an alias
getServerActions :: Server -> [String]
getServerActions = serverActions

--server initialization, requires all of the information the server needs
initServer :: String -> [String] -> (String, [String]) -> [String] ->
  [String] -> [Key] -> Map.Map String [String] -> Map.Map Domain Known ->
  Map.Map Nonce Known -> Map.Map (String, String) Known ->
  Map.Map String [String] ->
  Map.Map Url [([String], [ServerRule], Response, Maybe Response)] ->
  Map.Map Nonce [ServerRule] -> Map.Map Nonce (Nonce, Request) ->
  Map.Map Nonce Response -> [Int] -> Server
initServer sID  auto pData kDesc track keys known serverData sessionData pSession seenL rules pReq eRes pRes nonceL =
    Server {serverIdentifier = sID, autoGenerated = auto,
      persistentData = pData, keyDesc = kDesc, trackingDesc = track,
      knownKeys = inv (Pri sID):Pri sID:keys, knownData = known,
      serverKnowledge = serverData, serverSession = sessionData,
      persistentSession= pSession, seen = seenL, serverRules = rules,
      pendingSRequests = pReq, expectedResponses = eRes,
      pendingSResponses = pRes, sNonceList = nonceL}

--Server with an empty initial state (besides its rules and known data)
initEmptyServer :: String -> [String] -> (String, [String]) -> [String] ->
  [String] -> [Key] ->  Map.Map String [String] ->
  Map.Map Url [([String], [ServerRule], Response, Maybe Response)] -> Server
initEmptyServer sID auto pData kDesc track keys known rules =
    initServer sID auto pData kDesc track keys known Map.empty Map.empty
      Map.empty Map.empty rules Map.empty Map.empty Map.empty [1..]

privateKey:: Server -> Key
privateKey cServer = pKey
    where sID = serverIdentifier cServer
          pKey = Pri sID

errorResponse :: String -> Url -> Nonce -> Response
errorResponse bid url nonc =
    Response { destinationIdentifier = bid, origin = url, resNonce = nonc,
       csp = Csp { scriptList = [], frameList = [], resourceList = []},
       componentList =[component], instructionList = PageInstructions { autoList = [],
         conditionalList = []}, fileList = Map.empty}
    where inst = Instruction (Left 1) Rule { rType = RuleType Normal Full,
                   rMethod = Post, rUrl = Left url,
                   rContents = Map.singleton "Error!! :(" "?" }
          component = Component { cOrigin = url, cList = [inst], cPos = 1,
                        cVisible = True}

compliesWithSRule:: Known -> [String] -> Bool
compliesWithSRule _ []= True
compliesWithSRule knowledge requirements = all (`Map.member` knowledge) requirements

getRule:: Bool -> Known -> [([String], [ServerRule], Response, Maybe Response)]
  -> Maybe ([ServerRule], Maybe Response)
getRule _ _ [] = Nothing
getRule valid knowledge (x:xs)
    | compliesWithSRule knowledge requirements =
        if valid
            then Just (sReqRules, Just response)
            else Just ([], errRes)
    | otherwise = getRule valid knowledge xs
    where (requirements, sReqRules, response, errRes) = x

mapFromSigValue'::[String] -> [(String, String)] -> [(String, String)]
mapFromSigValue' [] accum = accum
mapFromSigValue' [_] _ = []
mapFromSigValue' (x:y:xs) accum = mapFromSigValue' list ((x, val):accum)
    where (val, list) = if "Url" `isPrefixOf` y
                            then (unwords(y:takeWhile (/="}") xs ++ ["}"]),
                                    drop 1 (dropWhile (/= "}") xs))
                            else (y,xs)

mapFromSigValue:: [String] -> Known
mapFromSigValue [] = Map.empty
mapFromSigValue [_] = Map.empty
mapFromSigValue values = Map.fromList rList
    where rList = mapFromSigValue' values []

valuesFromSignature:: [Key] -> String -> Known
valuesFromSignature kList received = result
    where (Sig val key) = read received ::Enc String
          value = if inv key `elem` kList
                    then verify (Sig val key) (inv key)
                    else Nothing
          result = maybe Map.empty (mapFromSigValue . words) value


checkInfo:: Known -> Map.Map String [String] -> [Key] -> Bool
checkInfo received known keys = checkResult && verified
    where toCheck = Map.filterWithKey (\k _ -> k `Map.member` known) received
          checkResult = and $ Map.foldWithKey
            (\k v a -> (v `elem` (known Map.! k)):a ) [] toCheck
          signed = Map.elems $ Map.filter (isPrefixOf "Sig") received
          toVerify = map (valuesFromSignature keys) signed
          verified = all (\m -> Map.union (Map.intersection m received)
                                             received == received ) toVerify



appendSession:: Maybe Known -> (String, [String]) ->
   Map.Map (String, String) Known -> Map.Map (String, String) Known
appendSession Nothing _ cSession = cSession
appendSession (Just known) (name, content) cSession
    | null name = Map.empty
    | isJust nvalue && null content =
         Map.union (Map.singleton (name, fromJust nvalue) known) cSession
    | isJust nvalue =
         let nscontent = Map.filterWithKey (\k _ -> k `elem` content) known
             nSession = Map.singleton (name, fromJust nvalue) nscontent
         in Map.union nSession cSession
    | otherwise = cSession
    where nvalue = Map.lookup name known

appendSeen:: Maybe Known -> [String] -> Map.Map String [String] ->
  Map.Map String [String]
appendSeen _ _ _ = Map.empty

appendKeys:: Maybe Known -> [String] -> [Key] -> [Key]
appendKeys _ _ keys = keys

requestReceived:: Server -> Request -> Server
requestReceived cServer request =
    Server { serverIdentifier = sID, autoGenerated = auto,
      persistentData = pData, keyDesc = kDesc, trackingDesc = track,
      knownKeys = nKeys, knownData = kData, serverKnowledge = sKnown,
      serverSession = Map.insert rNonce sessionInfo sSession,
      persistentSession = npSession, seen = nSeen, serverRules = sRules,
      pendingSRequests = Map.insert rNonce ruleRequests sPReq,
      expectedResponses= eSResp,
      pendingSResponses = Map.insert rNonce ruleResponse spRes,
      sNonceList= sNL }
    where (Server { serverIdentifier = sID, autoGenerated = auto,
            persistentData = pData, keyDesc = kDesc, trackingDesc = track,
            knownKeys = keys, knownData = kData, serverKnowledge = sKnown,
            serverSession = sSession, persistentSession = pSession,
            seen = cSeen, serverRules = sRules, pendingSRequests = sPReq,
            expectedResponses= eSResp, pendingSResponses = spRes,
            sNonceList= sNL }) = cServer
          (Request { originIdentifier = bID, destination = dUrl,
            reqNonce = rNonce, payload = reqInfo }) = request
          validUrl = Map.lookup dUrl sRules
          validRequest = checkInfo reqInfo kData keys
          validRule = getRule validRequest reqInfo (fromMaybe [] validUrl)
          requestExtraInfo = Map.fromList [("dID", bID), ("dUrl", show dUrl)]
          sessionInfo = Map.union requestExtraInfo reqInfo
          (ruleRequests, mRuleRes) = fromMaybe ([], Nothing) validRule
          ruleResponse = fromMaybe (errorResponse bID dUrl rNonce) mRuleRes
          npSession = appendSession (Just sessionInfo) pData pSession
          nSeen = appendSeen (Just sessionInfo) track cSeen
          nKeys = appendKeys (Just sessionInfo) kDesc keys

getRequestRule:: [ServerRule] -> Maybe ServerRule
getRequestRule [] = Nothing
getRequestRule (x:_) = Just x

getKnownElems :: Maybe Known -> [String] -> Known
getKnownElems _ [] = Map.empty
getKnownElems Nothing _ = Map.empty
getKnownElems (Just known) list = result
    where result = Map.filterWithKey (\k _ -> k `elem` list) known

getGKnownElems :: Map.Map String [String] -> [String] -> Known
getGKnownElems _ [] = Map.empty
getGKnownElems kData list = result
    where result = Map.mapMaybeWithKey (\k v -> if k `elem` list
                                                   then Just (head v)
                                                   else Nothing) kData

genAutoElem :: Nonce -> [String] -> [String] -> Known
genAutoElem _ [] _ = Map.empty
genAutoElem _ _ [] = Map.empty
genAutoElem nonce auto list = Map.fromList result
    where elems = filter (`elem` auto) list
          result = map (\y -> (y, y++ nonce)) elems


requestFromRule :: String -> Map.Map String [String]-> Int ->
  Map.Map Domain Known -> Maybe Known-> [String] -> Maybe ServerRule ->
  Maybe Request
requestFromRule _ _ _ _ _ _ Nothing = Nothing
requestFromRule sID kData nonce know kInfo auto rule
    | isJust reqUrl && all (`elem` Map.keys rPayload) frContent =
        Just Request { originIdentifier = sID, destination = fromJust reqUrl,
          reqNonce = newNonce, method = ruleMethod, payload =rPayload }
    | otherwise = Nothing
    where (Just ServerRule { sReqMethod= ruleMethod, sReqUrl = ruleDest,
            sReqContents = ruleContent }) = rule
          info = fromMaybe Map.empty kInfo
          reqUrl = either Just (\b -> fmap read (Map.lookup b info)) ruleDest
          newNonce = "nonce"++sID ++ show nonce
          cContent = filter (not . isInfixOf " = hash") ruleContent
          contentKnown = getKnownElems (Map.lookup (maybeUrlDomain reqUrl) know) cContent
          contentInfo = getKnownElems kInfo cContent
          autoInfo = genAutoElem newNonce auto cContent
          gKInfo = getGKnownElems kData cContent
          pPayload = Map.unions [gKInfo, autoInfo, contentKnown, contentInfo]
          hContent = filter (isInfixOf " = hash") ruleContent
          hPayload = foldl (\acc hval -> let (a,b) = break (=='=') hval
                                             k = dropWhileEnd (==' ') a
                                             v = hash (dropWhile (==' ') b)
                                                   pPayload
                                         in maybe Map.empty
                                              (\val -> Map.insert k val acc) v)
                       Map.empty hContent
          frContent = cContent ++ map (takeWhile (/= ' ')) hContent
          rPayload = Map.union pPayload hPayload

sendRequest::Server -> Nonce -> (Server, Maybe Request)
sendRequest cServer nonce
    | isJust generatedRequest =
        (Server { serverIdentifier = sID, autoGenerated = auto,
          persistentData = pData, keyDesc = kDesc, trackingDesc = track,
          knownKeys = keys, knownData = kData, serverKnowledge = sKnown,
          serverSession = sSession, persistentSession = pSession, seen = cSeen,
          serverRules = sRules,
          pendingSRequests = Map.insert nonce (tail (fromJust ruleList)) sPReq,
          expectedResponses= Map.insert ("nonce" ++ sID ++ show (head sNL))
            (nonce, fromJust generatedRequest) eSResp,
          pendingSResponses = spRes, sNonceList= tail sNL }, generatedRequest)
    | otherwise =
        (Server { serverIdentifier = sID, autoGenerated = auto,
          persistentData = pData, keyDesc = kDesc, trackingDesc = track,
          knownKeys = keys, knownData = kData, serverKnowledge = sKnown,
          serverSession = sSession, persistentSession = pSession, seen = cSeen,
          serverRules = sRules, pendingSRequests = Map.delete nonce sPReq,
          expectedResponses= Map.delete nonce eSResp,
          pendingSResponses = Map.insert nonce eResponse spRes,
          sNonceList= sNL }, Nothing)
    where (Server { serverIdentifier = sID, autoGenerated = auto,
            persistentData = pData, keyDesc = kDesc, trackingDesc = track,
            knownKeys = keys, knownData = kData, serverKnowledge = sKnown,
            serverSession = sSession, persistentSession = pSession,
            seen = cSeen, serverRules = sRules, pendingSRequests = sPReq,
            expectedResponses= eSResp, pendingSResponses = spRes,
            sNonceList= sNL }) = cServer
          ruleList = Map.lookup nonce sPReq
          rule = maybe Nothing getRequestRule ruleList
          reqKnowledge = Map.lookup nonce sSession
          generatedRequest = requestFromRule sID kData (head sNL) sKnown
            reqKnowledge auto rule
          bID =  fromMaybe Map.empty reqKnowledge Map.! "dID"
          dUrl = read (fromMaybe Map.empty reqKnowledge Map.! "dUrl")
          eResponse = errorResponse bID dUrl nonce

expectedResponse:: Request -> Response -> Bool
expectedResponse request response
    | oID == dID && dUrl == oUrl && sentNonce == recNonce = True
    | otherwise = False
    where (Request { originIdentifier = oID, destination = dUrl,
            reqNonce = sentNonce}) = request
          (Response { destinationIdentifier = dID, origin = oUrl,
            resNonce = recNonce}) = response

fileContents :: WebFile -> Known
fileContents file = contents
    where (WebFile { fContent = contents })= file

maybeUrlDomain :: Maybe Url -> Domain
maybeUrlDomain Nothing = ""
maybeUrlDomain (Just url) = server url

filesToShared:: Map.Map (Either String Url) WebFile -> Map.Map Domain Known
filesToShared recFiles
    | recFiles /= Map.empty =
        Map.mapKeys (either (const "") server) $ Map.map fileContents recFiles
    | otherwise = Map.empty

instructionToRule:: Instruction -> (Known, Maybe ServerRule)
instructionToRule instruction
    | validUrl = (reqKnown, Just ServerRule {sReqMethod = reqMethod,
                                  sReqUrl = reqUrl,
                                  sReqContents = Map.keys reqKnown})
    | otherwise = (reqKnown, Nothing)
    where (Instruction _ Rule { rMethod =reqMethod, rUrl = reqUrl,
            rContents = reqKnown })= instruction
          validUrl = either (\url -> server url /= "") (/="") reqUrl

accumParseResults:: (Known, [Maybe ServerRule]) -> Instruction ->
  (Known, [Maybe ServerRule])
accumParseResults (known, ruleList) instruction =
    (Map.union newInfo known, newRule:ruleList)
    where (newInfo, newRule) = instructionToRule instruction

parseInstructions:: [Instruction] -> (Known, [ServerRule])
parseInstructions iList = (info, catMaybes rules)
    where (info, rules) = foldl accumParseResults (Map.empty, []) iList

sResponseReceived:: Server -> Response -> Server
sResponseReceived cServer response
    | expected =
        Server { serverIdentifier = sID, autoGenerated = auto,
          persistentData = pData, keyDesc = kDesc, trackingDesc = track,
          knownKeys = nKeys, knownData = kData,
          serverKnowledge = Map.union newInfo sKnown,
          serverSession = Map.union sessionInfo sSession,
          persistentSession = npSession, seen = nSeen, serverRules = sRules,
          pendingSRequests = Map.union sessionRules sPReq,
          expectedResponses= Map.delete rNonce eSResp,
          pendingSResponses = spRes, sNonceList= sNL }
    | otherwise = cServer
    where (Server { serverIdentifier = sID, autoGenerated = auto,
            persistentData = pData, keyDesc = kDesc, trackingDesc = track,
            knownKeys = keys, knownData = kData, serverKnowledge = sKnown,
            serverSession = sSession, persistentSession = pSession,
            seen = cSeen, serverRules = sRules, pendingSRequests = sPReq,
            expectedResponses= eSResp, pendingSResponses = spRes,
            sNonceList= sNL }) = cServer
          (Response { resNonce = rNonce,
            instructionList = PageInstructions { autoList = rAList},
            fileList = rFList }) = response
          (oNonce, oReq) = fromMaybe ("", defaultRequest)
            (Map.lookup rNonce eSResp)
          expected = expectedResponse oReq response
          newInfo = filesToShared rFList
          (newSessionInfo, newRules) = parseInstructions rAList
          currentSession = fromMaybe Map.empty $ Map.lookup oNonce sSession
          currentRules = fromMaybe [] $ Map.lookup oNonce sPReq
          npSession = appendSession (Just currentSession) pData pSession
          nSeen = appendSeen (Just currentSession) track cSeen
          nKeys = appendKeys (Just currentSession) kDesc keys
          sessionInfo =Map.singleton oNonce
            $ Map.union newSessionInfo currentSession
          sessionRules = Map.singleton oNonce $ newRules ++ currentRules

getValue:: Known -> Known -> [String] -> Nonce -> String -> String
getValue known shared auto nonce identifier
    | Map.member identifier known = fromMaybe "" $ Map.lookup identifier known
    | Map.member identifier shared = fromMaybe "" $ Map.lookup identifier shared
    | identifier `elem` auto = identifier++nonce
    | otherwise = ""

fillEnc:: [Key] -> Known -> Maybe Known -> [String] -> Nonce -> String -> String
fillEnc keys known mShared auto nonce toEnc
    | key `elem` keys = show $ encrypt (unwords res) key
    | otherwise = ""
    where content = words toEnc
          incomplete = take (length content - 3) (drop 1 content)
          shared = fromMaybe Map.empty mShared
          res = map (\a -> a ++ " " ++ getValue known shared auto nonce a)
                  incomplete
          key = read . unwords $ drop (length content - 2) content

fillKey:: Known -> String -> String
fillKey known params
    | length (words params) > 3 = ""
    | t2 == "Pub" = t2 ++ " " ++ t3
    | t2 == "Pri" && t3 /= pID = ""
    | t2 == "Pri" && t3 == pID = t2 ++ " " ++ t3
    | t2 == "Shr" && pID /= "" && dID /= "" = "Shr " ++ pID ++ " " ++ dID
    | otherwise = ""
    where (_:t2:t3:_) = words params
          dUrl = Map.lookup "dUrl" known
          tdID = Map.lookup "dID" known
          dID = fromMaybe "" tdID
          pID = maybe "" (server. read) dUrl

fillData:: [Key] -> Known -> Maybe Known -> [String] ->
  Map.Map String [String] -> Nonce -> Known -> [Known]
fillData keys known sKnown auto kData nonce contents =
    [gKData, keyData, sigData, encData, pkData, sharedData, genData, contents]
    where incompleteData = Map.keys $ Map.filter (=="") contents
          pKeys = Map.filter (isPrefixOf "Key") contents
          keyData = Map.map (fillKey known) pKeys
          nKeys = nub (keys ++ map read (Map.elems keyData))
          sigRequired = Map.filter (isPrefixOf "Sig") contents
          encRequired = Map.filter (isPrefixOf "Enc") contents
          sigData = Map.map (fillEnc nKeys known sKnown auto nonce) sigRequired
          encData = Map.map (fillEnc nKeys known sKnown auto nonce) encRequired
          pkData = getKnownElems (Just known) incompleteData
          sharedData = getKnownElems sKnown incompleteData
          genData = genAutoElem nonce auto incompleteData
          gKData = getGKnownElems kData incompleteData

fillInstruction :: [Key] -> Map.Map Domain Known -> Known -> [String] ->
  Map.Map String [String] -> Nonce -> Instruction -> Maybe Instruction
fillInstruction keys shared known auto kData nonce inst
    | Map.null (Map.filter (=="") resultingData) && isJust nUrl =
        Just (Instruction trigger Rule { rType =instTYpe, rMethod =instRMethod,
               rUrl = Left (fromJust nUrl), rContents = resultingData })
    | otherwise = Nothing
    where (Instruction trigger Rule { rType =instTYpe, rMethod =instRMethod,
            rUrl = instUrl, rContents = iContent } )=inst
          nUrl = either Just (\b -> if b==""
                                 then Just emptyUrl
                                 else fmap read (Map.lookup b known)) instUrl
          sKnown = maybe Nothing (\a -> Map.lookup (server a) shared) nUrl
          resultingData = Map.unions (fillData keys known sKnown auto kData
                            nonce iContent)

fillComponent :: [Key] ->Map.Map Domain Known -> Known -> [String] ->
  Map.Map String [String] -> Nonce -> Component -> Maybe Component
fillComponent keys shared known auto kData nonce component
    | Nothing `notElem` resInsts = Just Component { cOrigin = cUrl,
        cList = catMaybes resInsts, cPos = pos, cVisible = visible }
    | otherwise = Nothing
    where (Component { cOrigin = cUrl, cList = instList, cPos = pos,
            cVisible = visible }) = component
          resInsts= map (fillInstruction keys shared known auto kData nonce)
                      instList

fillComponents :: [Key] -> [Component] -> Map.Map Domain Known -> Known ->
  [String] -> Map.Map String [String] -> Nonce -> Maybe [Component]
fillComponents _ [] _ _ _ _ _ = Just []
fillComponents keys components shared known auto kData nonce
    | Nothing `notElem` result = Just $ catMaybes result
    | otherwise = Nothing
    where result = map (fillComponent keys shared known auto kData nonce)
                     components

fillInstructions :: [Key] -> PageInstructions -> Map.Map Domain Known ->
  Known -> [String] -> Map.Map String [String] -> Nonce ->
  Maybe PageInstructions
fillInstructions keys instructions shared known auto kData nonce
    | Nothing `notElem` newAuto && Nothing `notElem` newCond =
        Just PageInstructions { autoList= catMaybes newAuto,
                conditionalList = catMaybes newCond }
    | otherwise = Nothing
    where (PageInstructions { autoList= autoInst,
            conditionalList = condInst })=instructions
          newAuto = map (fillInstruction keys shared known auto kData nonce)
                      autoInst
          newCond = map (fillInstruction keys shared known auto kData nonce)
                      condInst

fillFile:: [Key] -> Map.Map Domain Known -> Known -> [String] ->
  Map.Map String [String] -> Nonce -> Either String Url -> WebFile ->
  Maybe WebFile
fillFile _ _ _ _ _ _ (Left _) _  = Nothing
fillFile keys shared known auto kData nonce (Right url) file
    | url == emptyUrl = Nothing
    | Map.null (Map.filter (=="") resultingData) =
        Just WebFile { fTtl =ttl, fContent = resultingData }
    | otherwise = Nothing
    where (WebFile { fTtl =ttl, fContent = fData }) = file
          sKnown = Map.lookup (server url) shared
          resultingData = Map.unions (fillData keys known sKnown auto kData
                            nonce fData)

fillFiles:: [Key] -> Map.Map (Either String Url) WebFile ->
  Map.Map Domain Known -> Known -> [String] -> Map.Map String [String] ->
  Nonce -> Maybe (Map.Map (Either String Url) WebFile)
fillFiles keys fList shared known auto kData nonce
    | Map.null fList = Just Map.empty
    | length (Map.keys results) == length (Map.keys fList) = Just results
    | otherwise = Nothing
    where nFList = Map.mapKeys (\k -> if isRight k
                                        then k
                                        else
                                            let (Left b) = k
                                                v = Map.lookup b known
                                            in maybe k (Right . read) v) fList
          pResults = Map.mapMaybeWithKey (fillFile keys shared known auto kData nonce) nFList
          results = Map.mapKeys (\k -> if isRight k
                                         then let (Right v) = k
                                              in Right ( v { path = "" } )
                                         else k) pResults

generateResponse :: [Key] -> Map.Map String [String] -> Nonce ->
  Map.Map Domain Known -> Maybe Known -> [String] -> Maybe Response ->
  Maybe Response
generateResponse _ _ _ _ Nothing _ _ = Nothing
generateResponse _ _ _ _ _ _ Nothing = Nothing
generateResponse keys kData nonce sKnown (Just session) auto (Just response)
    | valid = Just Response { destinationIdentifier = newDestID,
                origin = read newOrigin, resNonce = nonce, csp = rCsp,
                componentList = fromJust newComponentList,
                instructionList = fromJust newInstList,
                fileList = fromJust newFileList }
    | otherwise = Just (errorResponse newDestID (read newOrigin) nonce)
    where (Response { destinationIdentifier = dID, origin = dUrl, csp = rCsp,
            componentList = rCList, instructionList = rInstructions,
            fileList = rFileL }) = response
          newDestID = fromMaybe dID $ Map.lookup "dID" session
          newOrigin = fromMaybe (show dUrl) $ Map.lookup "dUrl" session
          newComponentList = fillComponents keys rCList sKnown session auto
                               kData nonce
          newInstList = fillInstructions keys rInstructions sKnown session auto
                          kData nonce
          newFileList = fillFiles keys rFileL sKnown session auto kData nonce
          valid = newDestID /= "" && newOrigin /= "" && isJust newComponentList
                    && isJust newInstList && isJust newFileList


getNewKeys:: [Key] -> [String] ->Maybe Response -> [Key]
getNewKeys keys [] _ = keys
getNewKeys keys _ Nothing = keys
getNewKeys keys kDesc (Just res) = nKeys
    where (PageInstructions {autoList = aInst,
            conditionalList = cInst }) = instructionList res
          comp = concatMap cList (componentList res)
          inst = aInst ++ cInst ++ comp
          iContents = map (\(Instruction _ rule) -> rContents rule ) inst
          fContents = Map.elems (Map.map fContent (fileList res))
          contents = iContents++fContents
          nKeys = foldl (\a v -> appendKeys (Just v) kDesc a) keys contents


sendResponse:: Server -> Nonce -> (Server, Maybe Response)
sendResponse cServer nonce
    | null pendingReq && not expectedRes =
          let nKnown = Map.lookup nonce sSession
              pRes = Map.lookup nonce spRes
              res = generateResponse keys kData nonce sKnown nKnown auto pRes
              npSession = appendSession nKnown pData pSession
              nKeys = getNewKeys keys kDesc res
              nServer = Server { serverIdentifier = sID, autoGenerated = auto,
                          persistentData = pData, keyDesc = kDesc,
                          trackingDesc = track, knownKeys = nKeys,
                          knownData = kData, serverKnowledge = sKnown,
                          serverSession = Map.delete nonce sSession,
                          serverRules = sRules, persistentSession = npSession,
                          seen = cSeen,
                          pendingSRequests = Map.delete nonce sPReq,
                          expectedResponses= eSResp,
                          pendingSResponses = Map.delete nonce spRes,
                          sNonceList= sNL }
          in (nServer, res)
    | otherwise = (cServer, Nothing)
    where (Server { serverIdentifier = sID, autoGenerated = auto,
            persistentData = pData, keyDesc = kDesc, trackingDesc = track,
            knownKeys = keys, knownData = kData, serverKnowledge = sKnown,
            serverSession = sSession, persistentSession = pSession,
            seen = cSeen, serverRules = sRules, pendingSRequests = sPReq,
            expectedResponses= eSResp, pendingSResponses = spRes,
            sNonceList= sNL }) = cServer
          pendingReq = fromMaybe [] $ Map.lookup nonce sPReq
          expectedRes = Map.fold (\tuple accum -> nonce == fst tuple || accum)
            False eSResp


serverActions :: Server -> [String]
serverActions cServer = results
    where (Server { serverIdentifier = sID, pendingSRequests = sPReq,
            expectedResponses= eSResp, pendingSResponses = spRes,
            serverSession= sSession }) = cServer
          disabledReq = Map.fold (\a accum -> fst a :accum) [] eSResp
          peRequests = map (\a -> sID++ " -> server"++ ": Request "++ a) $
                         filter (`notElem` disabledReq)
                           (Map.keys $ Map.filter (not . null) sPReq)
          pResp = filter (`notElem` disabledReq)
            $ Map.keys (Map.filter null sPReq)
          pResponses = map (\k -> let sKnown = fromMaybe Map.empty
                                                      (Map.lookup k sSession)
                                      dID = fromMaybe ""
                                                      (Map.lookup "dID" sKnown)
                                        in sID ++ " -> " ++ dID ++ ": Response "
                                             ++ k)
                         $ Map.keys (Map.filterWithKey
                             (\k _ -> k `elem` pResp) spRes)
          results = peRequests ++ pResponses

serverOptionToEvent :: Server -> String ->
  (Server, Maybe Request, Maybe Response)
serverOptionToEvent cServer option
    | value == "Response" =
        let (nServer, res) = sendResponse cServer (head params)
        in (nServer, Nothing, res)
    | value == "Request" =
        let (nServer, req) = sendRequest cServer (head params)
        in (nServer, req, Nothing)
    | otherwise = (cServer, Nothing, Nothing)
    where (value:params) = drop 3 (words option)

serverStatus :: Server -> [String]
serverStatus cServer =
    [sID++" is:\n Waiting for Requests"] ++ req ++ res ++ res2
    where (Server { serverIdentifier= sID, pendingSRequests = sPReq,
            expectedResponses= eSResp, pendingSResponses = spRes }) = cServer
          disabledReq = Map.fold (\a accum -> fst a :accum) [] eSResp
          peRequests = filter (`notElem` disabledReq)
            (Map.keys $ Map.filter (not . null) sPReq)
          pResp = filter (`notElem` disabledReq)
            $ Map.keys (Map.filter null sPReq)
          pResponses =
            Map.keys (Map.filterWithKey (\k _ -> k `elem` pResp) spRes)
          req = if null peRequests
                    then []
                    else [" Can send requests"]
          res = if null pResponses
                    then []
                    else [" Can send responses"]
          res2 = if Map.null eSResp
                    then []
                    else [" Is expecting Responses"]
